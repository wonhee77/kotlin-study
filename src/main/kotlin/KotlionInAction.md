# 1장 코틀린이란 무엇이며, 왜 필요한가?

## 1.1 코틀린 맛보기

## 1.2 코틀린 주요 특성

코틀린의 주목적은 현재 자바가 사용되고 있는 모든 용도에 적합하면서도 더 간결하고 생산적이며 안전한 대체 언어를 제공하는 것이다.

코틀린은 자바와 마찬가지로 정적 타입 지정 언어이다. 모든 프로그램 구성 요소의 타입을 컴파일 시점에 알 수 있고 프로그램 안에서 객체의 필드나 메소드를 사용할 때마다 컴파일러가 타입을 검증해준다는 뜻이다.

자바와 달리 코틀린에서는 모든 변수의 타입을 프로그래머가 직접 명시할 필요가 없다. 대부분의 경우 코틀린 컴파일러가 문맥으로부터 변수 타입을 자동으로 유추할 수 있기 때문에 타입 선언을 생략해도 된다.

컴파일러가 문맥을 고려해 변수 타입을 결정하는 기능을 **타입 추론**이라고 한다.

정적 타입 지정의 장점

- 성능 : 실행 시점에 어떤 메소드를 호출해야할지 알아내는 과정이 없으므로 메소드 호출이 더 빠르다.
- 신뢰성 : 컴파일러가 프로그램의 정확성을 검증하기 때문에 오류가 날 확률이 적다.
- 유지 보수성 : 코드에서 다루는 객체가 어떤 타입에 속하는지 알 수 있다.
- 도구 지원 : 더 안전하게 리팩토링할 수 있고, 더 정확한 코드 완성 기능을 제공할 수 있으며, IDE의 지원 기능도 더 잘 만들 수 있다.

코틀린은 널이될 수 있는 타입을 지원한다. 컴파일 시점에 널 포인터 예외가 발생하는지를 검사할 수 있다.

코틀린은 함수 타입을 지원한다.

## 1.3 코틀린 응용

## 1.4 코틀린의 철학

## 1.5 코틀린 도구 사용

코틀린 소스코드를 저장할 때는 보통 .kt라는 확장자를 파일에 붙인다. 코틀린 컴파일러는 자바컴파일러가 자바 소스코드를 컴파일할 때와 마찬가지로 코틀린 소스코드를 분석해서 .class 파일을 만들어낸다.

코틀린 컴파일러로 컴파일한 코드는 코틀린 런타임 라이브러리에 의존한다. 런타임 라이브러리에는 코틀린 자체 표준 라이브러리 클래스와 코를린에서 자바 API의 기능을 확장한 내용이 들어있다.

## 1.6 요약

- 코틀린은 타입 추론을 지원하는 정적 타입 지정 언어다. 소스코드의 정확성과 성능을 보장하면서 소스코드를 간결하게 유지할 수 있다.
- 객체지향과 함수형 프로그래밍 스타일을 모두 지원한다.
- 실용적이며 안전하고 간결하며 상호운용성이 좋다.

# 2장 코틀린 기초

## 2.1 기본 요소: 함수와 변수

```kotlin
fun main(args: Array<String>) {
	println("Hello, world!")
}
```

- 함수를 선언할 때 fun 키워드를 사용한다.
- 파라미터 이름 뒤에 타입을 쓴다. 변수를 선언할 때도 마찬가지이다.
- 함수를 클래스 안에 넣지 않고 최상위 수준에 정의할 수 있다.
- 배열도 일반적인 클래스와 마찬가지로 자바와 달리 배열 처리를 위한 문법이 따로 존재하지 않는다.
- println으로 콘솔에 프린트를 한다. 간편하게 쓰기 위한 래퍼이다.
- 세미 콜론을 붙이지 않는다.

### 2.1.2 함수

함수의 반환 타입은 파라미터 목록의 닫는 괄호 다음에 온다. 괄호와 반환 타입 사이를 :으로 구분해야 한다.

```kotlin
fun max(a: Int, b: Int) : Int {
	return if (a > b) a else b
}
```

코틀린에서 if는 식(expression)이지 문(statement)가 아니다. 식은 값을 만들어 내고 다른 식의 하위 요소로 계산에 참여할 수 있는 반면 문은 자신을 둘러싸고 있는 가장 안쪽 블록의 최상위 요소로 존재하며 아무런 값도 만들어 내지 않는다. 자바에서는 모든 제어 구조가 문이지만 코틀린에서는 루프를 제외한 대부분의 제어 구조가 식이다.

**식이 본문인 함수**

```kotlin
fun max(a : Int, b : Int) : Int = if (a > b) a else b
```

본문이 중괄호로 둘러싸인 함수를 블록이 본문인 함수라고 부르고, 등호와 식으로 이뤄진 함수를 식이 본문인 함수라고 부른다.

코틀린은 식이 본문인 함수가 자주 쓰이고 단순한 산술식이나 함수 호출 식뿐 아니라 if, when, try 등의 더 복잡한 식도 자주 쓰인다.

반환 타입을 생략하면 더 간략하게 만들 수 있다.

```kotlin
fun max(a : Int, b : Int) = if (a > b) a else b
```

식이 본문인 함수의 경우 굳이 사용자가 반환 타입을 지정하지 않아도 컴파일러가 함수 본문 식을 분석해 식의 결과 타입을 반환 타입으로 지정해준다. 타입 추론

식이 본문인 함수의 반환 타입만 생략 가능하다.

### 2.1.3 변수

코틀린에서는 타입 지정을 생략하는 경우가 흔하다.

초기화 식을 사용하지 않고 변수를 선언하려면 변수 타입을 반드시 명시해야 한다.

```kotlin
val answer: Int
answer = 42
```

**변경 가능한 변수와 변경 불가능한 변수**

- val - 변경 불가능한 참조를 저장하는 변수. 자바의 final 변수이다.
- var - 변경 가능한 참조. 자바의 일반 변수에 해당

기본적으로는 모든 변수를 val 키워드로 불변 변수로 선언하고 나중에 꼭 필요할 때에만 var로 변경하자.

### 2.1.4 더 쉽게 문자열 형식 지정: 문자열 템플릿

```kotlin
println("Hello, $name!")
println("Hello, ${args[0]}!") // 복잡한 식도 중괄호로 감싸서 템플릿 안에 넣을 수 있다.
```

## 2.2 클래스와 프로퍼티

```kotlin
class Person(val name: String) // private final 필드, 생성자, getter 생성
```

이런 코드가 없이 데이터만 저장하는 클래스를 값 객체라고 부른다. 코틀린의 기본 가시성은 public 이다.

### 2.2.1 프로퍼티

자바에서는 필드와 접근자를 한데 묶어 프로퍼티라고 부른다. 코틀린은 프로퍼티를 언어 기본 기능으로 제공하며,

코틀린 프로퍼티는 자바의 필드 접근자 메소드를 완전히 대신한다.

```kotlin
class Person(
	val name: String, // 읽기 전용 프로퍼티로 비공개 필드와 게터 생성
	var isMarried: Boolean // 쓸 수 있는 프로퍼티로 비공개 필드, 게터, 세터를 만든다.
)
```

게터와 세터의 이름을 정하는 규칙의 예외

이름이 is로 시작하는 프로퍼티의 게터는 get이 붙지 않고 원래 이름을 그래도 사용

세터에서는 is를 set으로 바꾼다.

생성자를 호출할 때는 new 키워드를 붙일 필요가 없다.

값을 꺼낼때는 get 없이 그대로 꺼낼 수 있으며 set 할 때도 person.isMarried = false 로 set할 수 있다.

### 2.2.2 커스텀 접근자

```kotlin
class Rectangler(val hight: Int, val width: Int) {
	val isSquare: Boolean
		get() {
			return height == width
		}
}
```

### 2.2.3 코틀린 소스코드 구조: 디렉터리와 패키지

모든 코틀린 파일의 맨 앞에 package문을 넣을 수 있다. 그러면 그 파일 안에 있는 모든 선언이 해당 패키지에 들어간다. 코틀린에서는 클래스 임포트와 함수 임포트에 차이가 없으며 모든 선언을 import 키워드로 가져올 수 있다.

## 2.3 선택 표현과 처리: enum과 when

### 2.3.1 enum 클래스 정의

```kotlin
enum class Color {
RED, ORANGE, BLUE
```

자바에서는 enum을 사용하지만 코틀린에서는 enum class를 사용한다. 코틀린에서 enum은 소프트 키워드라 불리는 존재다. enum은 class 앞에 있을 때는 특별한 의미를 지니지만 다른 곳에서는 이름에 사용할 수 있다.

```kotlin
enum class Color(
	val r: Int, val g: Int, val b: Int
) {
	RED(255,0,0) ORANGE(255, 165,0); // 반드시 ;를 붙여줘야 한다.
	
	fun rgb() = (r * 256 + g) * 256 + b
}
```

enum 클래스 안에 메소드를 정의하는 경우가 유일하게 ;가 필요한 부분이다.

### 2.3.2 when으로 enum 클래스 다루기

if와 마찬가지로 when도 값을 만들어내는 식이다. 따라서 식이 본문인 함수에 when을 바로 사용할 수 있다.

```kotlin
fun getMnemonic(color: Color) = 
	when (color) {
		Color.RED -> "Richard"
		Color.ORANGE -> "Of"
		...
	}
```

자바와 달리 각 분기의 끝에 break를 넣지 않아도 된다. 한 분기 안에서 여러 값을 매치 패턴으로 사용할 수도 있다. [Color.RED](http://Color.RED), [Color.ORANGE](http://Color.ORANGE) → “”

상수 Color를 import하면 코드를 더 간단하게 만들 수 있다.

### 2.3.3 when 임의의 객체를 함께 사용

코틀린의 when은 자바의 switch보다 강력하다. 본기 조건에 상수만을 사용할 수 있는 자바와는 달리 코틀린에서는 임의의 객체를 허용한다.

```kotlin
fun mix(c1 : Color, c2: Color) = 
	when (setOf(c1, c2) {
		setOf(RED, YELLOW) -> ORANGE
		else -> throw Exception("Dirty color")
```

### 2.3.4 인자 없는 when 사용

불필요한 가비지 객체 생성을 방지하기 위해 인자가 없는 when을 사용할 수 있다.

when에 아무 인자도 없으려면 각 분기의 조건이 불리언 결과를 계산하는 식이어야 한다.

### 2.3.5 스마트 캐스트: 타입 검사와 타입 캐스트를 조합

```kotlin
interface Expr
class Num(val value: Int): Expr // 클래스가 구현하는 인터페이슬 지정하기 위해서 :를 사용한다.
class Sum(val left: Expr, val right: Expr) : Expr
```

(1 + 2) + 4 라는 식을 저장하면 Sum(Sum(Num(1), Num(2)), Num(4)) 라는 구초의 객체가 생긴다.

코틀린에서는 is를 사용해 변수 타입을 검사한다. 자바의 InstanceOf와 비슷하지만 자바에서는 타입 검사 후 명시적 타입캐스팅을 진행해야한다. 코틀린에서는 프로그래머 대신 컴파일러가 캐스팅을 해준다. 어떤 변수가 원하는 타입인지 일단 is로 검사하고 나면 굳이 변수를 원하는 타입으로 캐스팅하지 않아도 컴파일러가 캐스팅을 수행해준다. 이를 스마트 캐스트라고 한다.

스마트 캐스트는 is로 변수에 든 값의 타입을 검사한 다음 그 값이 바뀔 수 없는 경우에만 작동한다. 프로퍼티는 반드시 val이어야 하며 커스텀 접근자를 사용한것이어도 안 된다.

원하는 타입으로 명시적으로 타입 캐스팅하려면 as 키워드를 사용한다.

### 2.3.7 if와 when의 분기에서 블록 사용

if나 when 모두 분기에 블록을 사용할 수 있다. 그런 경우 블록의 마지막 문장이 블록 전체의 결과가 된다. 블록이 값을 만들어내야 하는 경우에는 '블록의 마지막 식이 블록의 결과'라는 규칙이 항상 성립한다. 하지만 함수에서는 식이 본문이 함수는 블록을 본문으로 가질 수 없고 블록이 본문인 함수는 내부에 return 문이 반드시 있어야 한다.

## 2.4 대상을 이터레이션: while과 for 루프

코틀린 while 루프는 자바와 동일하며, for는 자바의 for-each 루프에 해당하는 형태만 존재한다.코틀린의 for는 C#과 마찬가지로 for <아이템> in <원소들> 형태를 취한다.

### 2.4.1 while 루프

코틀린에는 while과 do-while 루프가 있다. do-while문은 맨 처음에 무조건 본문을 한 번 실행한 다음, 조건이 참인 동안 본문을 반복한다.

### 2.4.2 수에 대한 이터레이션: 범위와 수열

코틀린에는 자바의 for 루프에 해당하는 요소가 없으며, 이런 루프의 가장 흔한 용례인 초깃값, 증가 값, 최종 값을 사용한 루프를 대신하기 위해 코틀린에서는 범위를 사용한다. 범위는 기본적으로 두 값으로 이뤄진 구간이다.

```kotlin
val oneToTen = 1..10
```

코틀린의 범위는 양쪽을 포함하는 폐구간이다.

끝을 포함하지 않는 범위에 대해서는 1 until 10을 사용하면 된다. (1 .. 10-1과 같음)

### 2.4.3 맵에 대한 이터레이션

.연산자를 숫자 타입의 값뿐 아니라 문자 타입의 값에도 적용할 수 있다. 맵에서 get과 put대신 map[key]나 map[key] = value를 사용해 값을 가져오고 설정할 수 있다.

```kotlin
val binaryReps = TreeMap<Char, String>()
for ((letter, binary) in binaryReps) { // 맵에 대한 이터레이션
	println("$letter = $binary")
}

// for문도 이터레이션 사용 가능 
val list = arrayListOf("10", "11", "1001")
for ((index, element) in list.withIndex()) { // 인덱스와 함께 컬렉션을 이터레이션
	println("$index: $element")
}
```

### 2.4.4 in으로 컬렉션이나 범위의 원소 검사

in 연산자를 사용해 어떤 값이 범위에 속하는지 검사할 수 있으며, 반대로 !in을 사용하면 어떤 값이 범위에 속하지 않는지 검사할 수 있다.

```kotlin
fun isLetter(c: Char) = c in 'a'..'z' || c in 'A'..'Z' // 'a' <= c && c <= 'z'로 변환 된다.
```

범위는 문자에만 국한되지 않고 비교가 가능한 클래스라면 그 클래스의 인스턴스 객체를 사용해 범위를 만들 수 있다.

## 2.5 코틀린의 예외 처리

코틀린의 예외 처리는 자바나 다른 언어의 예외 처리와 비슷하다. 함수는 정상적으로 종료할 수 있지만 오류가 발생하면 예외를 던질 수 있다.

다른 클래스와 마찬가지로 인스턴스를 생성할 때 new를 붙일 필요가 없다.

자바와 달리 코틀린의 throw는 식이므로 다른 식에 포함될 수 있다.

### 2.5.1 try, catch, finally

자바와 마찬가지로 예외를 처리하려면 try와 catch, finally 절을 함께 사용한다.

catch 문에서는 예외 타입을 :의 오른쪽에 쓴다. catch (e : RuntimeException)

자바코드와 가장 큰 차이는 throws절이 코드에 없다는 점이다. 코틀린은 체크예외와 언체크예외를 구분하지 않는다. 함수가 던지는 예외를 지정하지 않고 발생한 예외를 잡아내도 되고 잡아내지 않아도 된다.

자바는 체크 예외처리를 강제하기 때문에 의미 없이 예외를 던지거나 예외를 잡되 처리하지 않는 경우가 흔하다.

### 2.5.2 try를 식으로 사용

코틀린의 try 키워드는 if나 when과 마찬가지로 식이다. 따라서 try의 값을 변수에 대입할 수 있다. if와 달리 try의 본문은 반드시 중괄호로 둘러싸야 한다.

## 2.6 요약

- 함수를 정의할 때 fun 키워드를 사용하고 val, var는 각각 읽기 전용 변수와 변경 가능한 변수를 선언할 때 쓰인다.
- 문자열 템플릿을 사용하면 코드가 간결해진다. 변수 이름 앞에 $를 붙이거나 ${식} 처럼 ${}로 둘러싸면 변수나 식의 값을 문자열 안에 넣을 수 있다.
- 값 객체 클래스를 간결하게 표현할 수 있다.
- if는 코틀린에서 식이며, 값을 만들어 낸다.
- when은 자바의 switch와 비슷하지만 더 강력하다.
- 어떤 변수의 타입 검사를 하고 나면 굳이 그 변수를 캐스팅하지 않아도 검사한 타입의 변수처럼 사용할 수 있다.
