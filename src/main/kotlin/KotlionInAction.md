# 1장 코틀린이란 무엇이며, 왜 필요한가?

## 1.1 코틀린 맛보기

## 1.2 코틀린 주요 특성

코틀린의 주목적은 현재 자바가 사용되고 있는 모든 용도에 적합하면서도 더 간결하고 생산적이며 안전한 대체 언어를 제공하는 것이다.

코틀린은 자바와 마찬가지로 정적 타입 지정 언어이다. 모든 프로그램 구성 요소의 타입을 컴파일 시점에 알 수 있고 프로그램 안에서 객체의 필드나 메소드를 사용할 때마다 컴파일러가 타입을 검증해준다는 뜻이다.

자바와 달리 코틀린에서는 모든 변수의 타입을 프로그래머가 직접 명시할 필요가 없다. 대부분의 경우 코틀린 컴파일러가 문맥으로부터 변수 타입을 자동으로 유추할 수 있기 때문에 타입 선언을 생략해도 된다.

컴파일러가 문맥을 고려해 변수 타입을 결정하는 기능을 **타입 추론**이라고 한다.

정적 타입 지정의 장점

- 성능 : 실행 시점에 어떤 메소드를 호출해야할지 알아내는 과정이 없으므로 메소드 호출이 더 빠르다.
- 신뢰성 : 컴파일러가 프로그램의 정확성을 검증하기 때문에 오류가 날 확률이 적다.
- 유지 보수성 : 코드에서 다루는 객체가 어떤 타입에 속하는지 알 수 있다.
- 도구 지원 : 더 안전하게 리팩토링할 수 있고, 더 정확한 코드 완성 기능을 제공할 수 있으며, IDE의 지원 기능도 더 잘 만들 수 있다.

코틀린은 널이될 수 있는 타입을 지원한다. 컴파일 시점에 널 포인터 예외가 발생하는지를 검사할 수 있다.

코틀린은 함수 타입을 지원한다.

## 1.3 코틀린 응용

## 1.4 코틀린의 철학

## 1.5 코틀린 도구 사용

코틀린 소스코드를 저장할 때는 보통 .kt라는 확장자를 파일에 붙인다. 코틀린 컴파일러는 자바컴파일러가 자바 소스코드를 컴파일할 때와 마찬가지로 코틀린 소스코드를 분석해서 .class 파일을 만들어낸다.

코틀린 컴파일러로 컴파일한 코드는 코틀린 런타임 라이브러리에 의존한다. 런타임 라이브러리에는 코틀린 자체 표준 라이브러리 클래스와 코를린에서 자바 API의 기능을 확장한 내용이 들어있다.

## 1.6 요약

- 코틀린은 타입 추론을 지원하는 정적 타입 지정 언어다. 소스코드의 정확성과 성능을 보장하면서 소스코드를 간결하게 유지할 수 있다.
- 객체지향과 함수형 프로그래밍 스타일을 모두 지원한다.
- 실용적이며 안전하고 간결하며 상호운용성이 좋다.

# 2장 코틀린 기초

## 2.1 기본 요소: 함수와 변수

```kotlin
fun main(args: Array<String>) {
	println("Hello, world!")
}
```

- 함수를 선언할 때 fun 키워드를 사용한다.
- 파라미터 이름 뒤에 타입을 쓴다. 변수를 선언할 때도 마찬가지이다.
- 함수를 클래스 안에 넣지 않고 최상위 수준에 정의할 수 있다.
- 배열도 일반적인 클래스와 마찬가지로 자바와 달리 배열 처리를 위한 문법이 따로 존재하지 않는다.
- println으로 콘솔에 프린트를 한다. 간편하게 쓰기 위한 래퍼이다.
- 세미 콜론을 붙이지 않는다.

### 2.1.2 함수

함수의 반환 타입은 파라미터 목록의 닫는 괄호 다음에 온다. 괄호와 반환 타입 사이를 :으로 구분해야 한다.

```kotlin
fun max(a: Int, b: Int) : Int {
	return if (a > b) a else b
}
```

코틀린에서 if는 식(expression)이지 문(statement)가 아니다. 식은 값을 만들어 내고 다른 식의 하위 요소로 계산에 참여할 수 있는 반면 문은 자신을 둘러싸고 있는 가장 안쪽 블록의 최상위 요소로 존재하며 아무런 값도 만들어 내지 않는다. 자바에서는 모든 제어 구조가 문이지만 코틀린에서는 루프를 제외한 대부분의 제어 구조가 식이다.

**식이 본문인 함수**

```kotlin
fun max(a : Int, b : Int) : Int = if (a > b) a else b
```

본문이 중괄호로 둘러싸인 함수를 블록이 본문인 함수라고 부르고, 등호와 식으로 이뤄진 함수를 식이 본문인 함수라고 부른다.

코틀린은 식이 본문인 함수가 자주 쓰이고 단순한 산술식이나 함수 호출 식뿐 아니라 if, when, try 등의 더 복잡한 식도 자주 쓰인다.

반환 타입을 생략하면 더 간략하게 만들 수 있다.

```kotlin
fun max(a : Int, b : Int) = if (a > b) a else b
```

식이 본문인 함수의 경우 굳이 사용자가 반환 타입을 지정하지 않아도 컴파일러가 함수 본문 식을 분석해 식의 결과 타입을 반환 타입으로 지정해준다. 타입 추론

식이 본문인 함수의 반환 타입만 생략 가능하다.

### 2.1.3 변수

코틀린에서는 타입 지정을 생략하는 경우가 흔하다.

초기화 식을 사용하지 않고 변수를 선언하려면 변수 타입을 반드시 명시해야 한다.

```kotlin
val answer: Int
answer = 42
```

**변경 가능한 변수와 변경 불가능한 변수**

- val - 변경 불가능한 참조를 저장하는 변수. 자바의 final 변수이다.
- var - 변경 가능한 참조. 자바의 일반 변수에 해당

기본적으로는 모든 변수를 val 키워드로 불변 변수로 선언하고 나중에 꼭 필요할 때에만 var로 변경하자.

### 2.1.4 더 쉽게 문자열 형식 지정: 문자열 템플릿

```kotlin
println("Hello, $name!")
println("Hello, ${args[0]}!") // 복잡한 식도 중괄호로 감싸서 템플릿 안에 넣을 수 있다.
```

## 2.2 클래스와 프로퍼티

```kotlin
class Person(val name: String) // private final 필드, 생성자, getter 생성
```

이런 코드가 없이 데이터만 저장하는 클래스를 값 객체라고 부른다. 코틀린의 기본 가시성은 public 이다.

### 2.2.1 프로퍼티

자바에서는 필드와 접근자를 한데 묶어 프로퍼티라고 부른다. 코틀린은 프로퍼티를 언어 기본 기능으로 제공하며,

코틀린 프로퍼티는 자바의 필드 접근자 메소드를 완전히 대신한다.

```kotlin
class Person(
	val name: String, // 읽기 전용 프로퍼티로 비공개 필드와 게터 생성
	var isMarried: Boolean // 쓸 수 있는 프로퍼티로 비공개 필드, 게터, 세터를 만든다.
)
```

게터와 세터의 이름을 정하는 규칙의 예외

이름이 is로 시작하는 프로퍼티의 게터는 get이 붙지 않고 원래 이름을 그래도 사용

세터에서는 is를 set으로 바꾼다.

생성자를 호출할 때는 new 키워드를 붙일 필요가 없다.

값을 꺼낼때는 get 없이 그대로 꺼낼 수 있으며 set 할 때도 person.isMarried = false 로 set할 수 있다.

### 2.2.2 커스텀 접근자

```kotlin
class Rectangler(val hight: Int, val width: Int) {
	val isSquare: Boolean
		get() {
			return height == width
		}
}
```

### 2.2.3 코틀린 소스코드 구조: 디렉터리와 패키지

모든 코틀린 파일의 맨 앞에 package문을 넣을 수 있다. 그러면 그 파일 안에 있는 모든 선언이 해당 패키지에 들어간다. 코틀린에서는 클래스 임포트와 함수 임포트에 차이가 없으며 모든 선언을 import 키워드로 가져올 수 있다.

## 2.3 선택 표현과 처리: enum과 when

### 2.3.1 enum 클래스 정의

```kotlin
enum class Color {
RED, ORANGE, BLUE
```

자바에서는 enum을 사용하지만 코틀린에서는 enum class를 사용한다. 코틀린에서 enum은 소프트 키워드라 불리는 존재다. enum은 class 앞에 있을 때는 특별한 의미를 지니지만 다른 곳에서는 이름에 사용할 수 있다.

```kotlin
enum class Color(
	val r: Int, val g: Int, val b: Int
) {
	RED(255,0,0) ORANGE(255, 165,0); // 반드시 ;를 붙여줘야 한다.
	
	fun rgb() = (r * 256 + g) * 256 + b
}
```

enum 클래스 안에 메소드를 정의하는 경우가 유일하게 ;가 필요한 부분이다.

### 2.3.2 when으로 enum 클래스 다루기

if와 마찬가지로 when도 값을 만들어내는 식이다. 따라서 식이 본문인 함수에 when을 바로 사용할 수 있다.

```kotlin
fun getMnemonic(color: Color) = 
	when (color) {
		Color.RED -> "Richard"
		Color.ORANGE -> "Of"
		...
	}
```

자바와 달리 각 분기의 끝에 break를 넣지 않아도 된다. 한 분기 안에서 여러 값을 매치 패턴으로 사용할 수도 있다. [Color.RED](http://Color.RED), [Color.ORANGE](http://Color.ORANGE) → “”

상수 Color를 import하면 코드를 더 간단하게 만들 수 있다.

### 2.3.3 when 임의의 객체를 함께 사용

코틀린의 when은 자바의 switch보다 강력하다. 본기 조건에 상수만을 사용할 수 있는 자바와는 달리 코틀린에서는 임의의 객체를 허용한다.

```kotlin
fun mix(c1 : Color, c2: Color) = 
	when (setOf(c1, c2) {
		setOf(RED, YELLOW) -> ORANGE
		else -> throw Exception("Dirty color")
```

### 2.3.4 인자 없는 when 사용

불필요한 가비지 객체 생성을 방지하기 위해 인자가 없는 when을 사용할 수 있다.

when에 아무 인자도 없으려면 각 분기의 조건이 불리언 결과를 계산하는 식이어야 한다.

### 2.3.5 스마트 캐스트: 타입 검사와 타입 캐스트를 조합

```kotlin
interface Expr
class Num(val value: Int): Expr // 클래스가 구현하는 인터페이슬 지정하기 위해서 :를 사용한다.
class Sum(val left: Expr, val right: Expr) : Expr
```

(1 + 2) + 4 라는 식을 저장하면 Sum(Sum(Num(1), Num(2)), Num(4)) 라는 구초의 객체가 생긴다.

코틀린에서는 is를 사용해 변수 타입을 검사한다. 자바의 InstanceOf와 비슷하지만 자바에서는 타입 검사 후 명시적 타입캐스팅을 진행해야한다. 코틀린에서는 프로그래머 대신 컴파일러가 캐스팅을 해준다. 어떤 변수가 원하는 타입인지 일단 is로 검사하고 나면 굳이 변수를 원하는 타입으로 캐스팅하지 않아도 컴파일러가 캐스팅을 수행해준다. 이를 스마트 캐스트라고 한다.

스마트 캐스트는 is로 변수에 든 값의 타입을 검사한 다음 그 값이 바뀔 수 없는 경우에만 작동한다. 프로퍼티는 반드시 val이어야 하며 커스텀 접근자를 사용한것이어도 안 된다.

원하는 타입으로 명시적으로 타입 캐스팅하려면 as 키워드를 사용한다.

### 2.3.7 if와 when의 분기에서 블록 사용

if나 when 모두 분기에 블록을 사용할 수 있다. 그런 경우 블록의 마지막 문장이 블록 전체의 결과가 된다. 블록이 값을 만들어내야 하는 경우에는 '블록의 마지막 식이 블록의 결과'라는 규칙이 항상 성립한다. 하지만 함수에서는 식이 본문이 함수는 블록을 본문으로 가질 수 없고 블록이 본문인 함수는 내부에 return 문이 반드시 있어야 한다.

## 2.4 대상을 이터레이션: while과 for 루프

코틀린 while 루프는 자바와 동일하며, for는 자바의 for-each 루프에 해당하는 형태만 존재한다.코틀린의 for는 C#과 마찬가지로 for <아이템> in <원소들> 형태를 취한다.

### 2.4.1 while 루프

코틀린에는 while과 do-while 루프가 있다. do-while문은 맨 처음에 무조건 본문을 한 번 실행한 다음, 조건이 참인 동안 본문을 반복한다.

### 2.4.2 수에 대한 이터레이션: 범위와 수열

코틀린에는 자바의 for 루프에 해당하는 요소가 없으며, 이런 루프의 가장 흔한 용례인 초깃값, 증가 값, 최종 값을 사용한 루프를 대신하기 위해 코틀린에서는 범위를 사용한다. 범위는 기본적으로 두 값으로 이뤄진 구간이다.

```kotlin
val oneToTen = 1..10
```

코틀린의 범위는 양쪽을 포함하는 폐구간이다.

끝을 포함하지 않는 범위에 대해서는 1 until 10을 사용하면 된다. (1 .. 10-1과 같음)

### 2.4.3 맵에 대한 이터레이션

.연산자를 숫자 타입의 값뿐 아니라 문자 타입의 값에도 적용할 수 있다. 맵에서 get과 put대신 map[key]나 map[key] = value를 사용해 값을 가져오고 설정할 수 있다.

```kotlin
val binaryReps = TreeMap<Char, String>()
for ((letter, binary) in binaryReps) { // 맵에 대한 이터레이션
	println("$letter = $binary")
}

// for문도 이터레이션 사용 가능 
val list = arrayListOf("10", "11", "1001")
for ((index, element) in list.withIndex()) { // 인덱스와 함께 컬렉션을 이터레이션
	println("$index: $element")
}
```

### 2.4.4 in으로 컬렉션이나 범위의 원소 검사

in 연산자를 사용해 어떤 값이 범위에 속하는지 검사할 수 있으며, 반대로 !in을 사용하면 어떤 값이 범위에 속하지 않는지 검사할 수 있다.

```kotlin
fun isLetter(c: Char) = c in 'a'..'z' || c in 'A'..'Z' // 'a' <= c && c <= 'z'로 변환 된다.
```

범위는 문자에만 국한되지 않고 비교가 가능한 클래스라면 그 클래스의 인스턴스 객체를 사용해 범위를 만들 수 있다.

## 2.5 코틀린의 예외 처리

코틀린의 예외 처리는 자바나 다른 언어의 예외 처리와 비슷하다. 함수는 정상적으로 종료할 수 있지만 오류가 발생하면 예외를 던질 수 있다.

다른 클래스와 마찬가지로 인스턴스를 생성할 때 new를 붙일 필요가 없다.

자바와 달리 코틀린의 throw는 식이므로 다른 식에 포함될 수 있다.

### 2.5.1 try, catch, finally

자바와 마찬가지로 예외를 처리하려면 try와 catch, finally 절을 함께 사용한다.

catch 문에서는 예외 타입을 :의 오른쪽에 쓴다. catch (e : RuntimeException)

자바코드와 가장 큰 차이는 throws절이 코드에 없다는 점이다. 코틀린은 체크예외와 언체크예외를 구분하지 않는다. 함수가 던지는 예외를 지정하지 않고 발생한 예외를 잡아내도 되고 잡아내지 않아도 된다.

자바는 체크 예외처리를 강제하기 때문에 의미 없이 예외를 던지거나 예외를 잡되 처리하지 않는 경우가 흔하다.

### 2.5.2 try를 식으로 사용

코틀린의 try 키워드는 if나 when과 마찬가지로 식이다. 따라서 try의 값을 변수에 대입할 수 있다. if와 달리 try의 본문은 반드시 중괄호로 둘러싸야 한다.

## 2.6 요약

- 함수를 정의할 때 fun 키워드를 사용하고 val, var는 각각 읽기 전용 변수와 변경 가능한 변수를 선언할 때 쓰인다.
- 문자열 템플릿을 사용하면 코드가 간결해진다. 변수 이름 앞에 $를 붙이거나 ${식} 처럼 ${}로 둘러싸면 변수나 식의 값을 문자열 안에 넣을 수 있다.
- 값 객체 클래스를 간결하게 표현할 수 있다.
- if는 코틀린에서 식이며, 값을 만들어 낸다.
- when은 자바의 switch와 비슷하지만 더 강력하다.
- 어떤 변수의 타입 검사를 하고 나면 굳이 그 변수를 캐스팅하지 않아도 검사한 타입의 변수처럼 사용할 수 있다.

# 3장 함수 정의와 호출

## 3.1 코틀린에서 컬렉션 만들기

```kotlin
val set = hashSetOf(1, 2, 3)
val list = arrayListOf(1, 2, 3)
val map = hashMapOf(1 to "one", 2 to "two") // to는 키워드가 아니라 일반 함수다.
```

```kotlin
>>> println(set.javaclass) // javaclass는 자바 getClass()에 해당하는 코틀린 코드
class.java.util.HashSet
```

이는 코틀린이 자신만의 컬렉션 기능을 제공하지 않는다는 뜻이다. 코틀린 컬렉션은 자바 컬렉션과 똑같은 클래스지만 더 많은 기능을 쓸 수 있다.

## 3.2 함수를 호출하기 쉽게 만들기

자바 컬렉션에는 디폴트 toString()구현이 들어가 있다. 코틀린 메소드로 원소 사이를 구분하고 괄호를 변경하는 function을 만들어 보자.

```kotlin
fun <T> joinToString(
	collection: Collection<T>,
	seperator: String,
	prefix: String,
	postfix: String
) : String {
	val result = StringBuilder(prefix)
	for ((index, element) in collection.withIndex()) {
		if (index > 0) result.append(seperator)
		result.applend(element)
	}
	result.append(postfix)
	return result.toString()
}
```

### 3.2.1 이름을 붙인 인자

함수의 인자로 전달한 문자열이 어떤 역할을 하는지 알기 어렵다.

```kotlin
joinToString(collection, seperator = " ", prefix = " ", postfix = ".")
```

코틀린으로 작성한 함수를 호출할 때는 함수에 전달하는 인자 중 일부의 이름을 명시할 수 있다. 어느 하나라도 이름을 명시하고 나면 혼동을 막기 위해 그 뒤에 오는 모든 인자는 이름을 꼭 명시해야 한다.

### 3.2.2 디폴트 파라미터 값

자바에서는 일부 클래스에서 오버로딩한 메소드가 너무 많아지는 문제가 있다. 코틀린에서는 함수 선언에서 파라미터의 디폴트 값을 지정할 수 있으므로 오버로드 중 상당수를 피할 수 있다.

```kotlin
fun <T> joinToString(
	collection: Collection<T>,
	seperator: String = ", ",
	prefix: String = "",
	postfix: String = ""
): String

>>> joinToString(list, ", ", "", "")
>>> joinToString(list)
>>> joinToString(list, "; "
```

일반 호출 문법을 사용하려면 함수를 선언할 때와 같은 순서로 인자를 지정해야 한다.

이름 붙은 인자를 사용하는 경우에는 인자 목록의 중간에 있는 인자를 생략하고, 지정하고 싶은 인자를 이름을 붙여서 순서와 관계없이 지정할 수 있다.

### 3.2.3 정적인 유틸리티 클래스 없애기: 최상위 함수와 프로퍼티

코틀린에서는 자바의 util 클래스와 같은 무의미한 클래스가 필요가 없다. 대신 함수를 직접 소스 파일의 최상위 수준, 모든 다른 클래스의 밖에 위치시키면 된다. 다른 클래스에서 사용할때는 클래스 이름 없이 패키지 이름만 import하면 된다.

JVM이 클래스 안에 들어있는 코드만을 실행할 수 있기 때문에 컴파일러는 이 파일을 컴파일 할 때 새로운 클래스를 정의해준다. 코틀린 컴파일러가 생성하는 클래스 이름은 최상위 함수가 들어있는 코틀린 소스 파일의 이름과 대응한다.

**최상위 프로퍼티**

함수와 마찬가지로 프로퍼티도 파일의 최상위 수준에 놓을 수 있다.
이런 프로퍼티의 값은 정적 필드에 저장된다.

## 3.3 메소드를 다른 클래스에 추가: 확장 함수와 확장 프로퍼티

확장 함수는 어떤 클래스의 멤버 메소드인 것처럼 호출할 수 있지만 그 클래스 밖에 선언된 함수다.

```kotlin
package strings

fun String.lastChar(): Char = this.get(this.length - 1)
```

확장 함수를 만들려면 추가하려는 함수 이름 앞에 그 함수가 확장할 클래스의 이름을 덧붙이기만 하면 된다. 클래스 이름을 수신 객체 타입이라 부르며 확장 함수가 호출되는 대상이 되는 값을 수신 객체라고 부른다.

String → 수신 객체 타입, this → 수신 객체

확장 함수 본문에도 this를 쓸 수 있고, this를 생략할 수도 있다.

확장 함수가 캡슐화를 깨지는 못한다. private 멤버나 protected 멤버를 사용할 수 없다.

### 3.3.1 임포트와 확장 함수

확장 함수를 사용하기 위해서는 그 함수를 임포트해야만 한다.

as 키워드를 사용하면 임포트한 클래스나 함수를 다른 이름으로 부를 수 있다.

```kotlin
import strings.lastChar as last
val c = "Kotlin".last()
```

### 3.3.2 자바에서 확장 함수 호출

내부적으로 확장 함수는 수신 객체를 첫 번째 인자로 받는 정적 메소드다. 그래서 확장 함수를 호출해도 다른 어댑터 객체나 실행 시점 부가 비용이 들지 않는다. 단지 정적 메소드를 호출하면서 첫 번째 인자로 수신 객체를 넘기기만 하면 된다.

### 3.3.3 확장 함수로 유틸리티 함수 정의

### 3.3.4 확장 함수는 오버라이드할 수 없다

어떤 클래스를 확장한 함수와 그 클래스 멤버 함수의 이름의 시그니처가 같다면 확장함수가 아니라 멤버 함수가 호출된다.

### 3.3.5 확장 프로퍼티

확장 프로퍼티를 사용하면 기존 클래스 객체에 대한 프로퍼티 형식의 구문으로 사용할 수 있는 API를 추가할 수 있다. 프로퍼티라는 이름으로 불리긴하지만 상태를 저장할 방법이 없기 때문에 확장 프로퍼티는 상태를 가질 수 없다.

```kotlin
val String.lastChar: Char
		get() = get(length - 1)
```

뒷받침하는 필드가 없어서 기본 게터 구현을 제공할 수 없으므로 최소한 게터는 꼭 정의를 해야한다.

## 3.4 컬렉션 처리: 가변 길이 인자, 중위 함수 호출, 라이브러리 지원

### 3.4.1 자바 컬렉션 API 확장

### 3.4.2 가변 인자 함수: 인자의 개수가 달라질 수 있는 함수 정의

가변 길이 인자는 메소드를 호출할 때 원하는 개수만큼 값을 인자로 넘기면 자바 컴파일러가 배열에 그 값들을 넣어주는 기능이다. 코틀린에서는 타입뒤에 …를 붙이는 대신에 파라미터 앞에 vararg 변경자를 붙인다.

이미 배열에 들어있는 원소를 가변 길이 인자로 넘길 때도 자바는 배열을 그냥 넘기면 되지만 코틀린에서는 명시적으로 풀어서 배열의 각 원소가 인자로 전달되게 해야 한다. 기술적으로는 스프레드 연산자가 작업을 해주지만 실제로는 전달하려는 배열 앞에 *를 붙이기만 하면 된다.

```kotlin
fun main(args: Array<String>) {
	val list = listOf("args: ", *args)
	println(list)
}
```

스프레드 연산자를 통해 배열에 있는 값과 여러 값을 함께 써서 함수를 호출할 수 있다.

### 3.4.3 값의 쌍 다루기: 중위 호출과 구조 분해 선언

맵을 만들려면 mapOf 함수를 사용한다.

```kotlin
val map = mapOf(1 to "one", 7 to "seven)
```

to라는 단어는 코틀린의 키워드가 아니라 중위 호출이라는 특별한 방식으로 to라는 일반 메소드를 호출한 것이다.

중위 호출 시에는 수신 객체와 유일한 메소드 인자 사이에 메소드 이름을 넣는다.

```kotlin
1.to("one") // "to" 메소드를 일반적인 방식으로 호출
1 to "one" // "to" 메소드를 중위 호출 방식으로 호출
```

인자가 하나뿐인 일반 메소드나 인자가 하나뿐인 확장 함수에 중위호출을 사용할 수 있다.

함수를 중위 호출에 사용하게 허용하고 싶으면 infix 변경자를 함수 선언 앞에 추가해야 한다.

```kotlin
infix fun Any.to(other: Any) = Pair(this, other)
```

Pair는 코틀린 표준 라이브러리 클래스로 두 원소로 이뤄진 순서쌍을 표한한다.
이런 기능을 구조 분해 선언이라고 부른다.

to 함수는 확장 함수다. to를 사용하면 타입과 관계없이 임의의 순서쌍을 만들 수 있다.

## 3.5 문자열과 정규식 다루기

코틀린은 다양한 확장 함수를 제공함으로써 표준 자바 문자열을 더 즐겁게 다루게 해준다.

### 3.5.1 문자열 나누기

String의 split 메소드의 구분 문자열은 정규식이다.

```kotlin
println("12.345".split("\\.|-".toRegex() // 정규식을 명시적으로 만든다.
```

코틀린 정규식 문법은 자바와 똑같다.

스플릿 확장 함수에서는 문자열을 하나 이상 인자로 받는 함수가 있다.

### 3.5.2 정규식과 3중 따옴표로 묶은 문자열

코틀린에서는 문자열에서 구분 문자열이 맨 나중에 나타난 곳 뒤의 부분 문자열을 반환하는 함수가 있다.

```kotlin
val path = "/Users/yole/kotlin-book/chaper.adoc"

val directory = path.substringBeforeLast("/")
val fullname = path.substringAfterLast("/")
```

3중 따옴표 문자열에서는 역슬래시를 포함한 어떤 문자도 이스케이프할 필요가 없다.

### 3.5.3 여러 줄 3중 따옴표 문자열

3중 따옴표를 쓰면 줄바꿈이 들어있는 프로그램 텍스트를 쉽게 문자열로 만들 수 있다.

## 3.6 코드 다음기: 로컬 함수와 확장

코틀린에서는 함수에서 추출한 함수를 원 함수 내부에 중첩시킬 수 있다.

코드 중복을 로컬 함수를 통해 제거할 수 있다.

```kotlin
Class user(val id: Int, val name: String, val address: String)

fun saveUser(user: User) {
	if (user.name.isEmpty()) {
		throw IlleagalArgumentException("Can't save user ${user.id}: empty Name")
	}
	if (user.address.isEmpty()) {
		throw IlleagalArgumentException("Can't save user ${user.id}: empty Address")
	}
```

코드의 중복이 많은 편은 아니지만 변수에따라 메소드가 길어질 수 있다.

```kotlin
Class user(val id: Int, val name: String, val address: String)

fun saveUser(user: User) {
	fun validate(user: User, value: String, fieldName: String) {
		if (value.isEmpty()) {
					throw IlleagalArgumentException("Can't save user ${user.id}: empty $fieldName")
		}
	}
	validate(user, user.name, "Name)
	validate(user, user.address, "Address")
}
```

로컬 함수는 자신이 속한 바깥 함수의 모든 파라미터와 변수를 사용할 수 있다.

```kotlin
Class user(val id: Int, val name: String, val address: String)

fun saveUser(user: User) {
	fun validate(value: String, fieldName: String) { // user에 직접 접근
		if (value.isEmpty()) {
					throw IlleagalArgumentException("Can't save user ${user.id}: empty $fieldName")
		}
	}
	validate(user, user.name, "Name)
	validate(user, user.address, "Address")
}
```

더 개선하고 싶다면 검증 로직을 User 클래스를 확장한 함수로 만들 수도 있다.

## 3.7 요약

- 코틀린은 자체 컬렉션 클래스를 정의하지 않지만 자바 클래스를 확장해서 더 풍부한 API를 제공한다.
- 함수 파라미터의 디폴트 값을 정의하면 오버로딩한 함수를 정의할 필요성이 줄어든다.
- 코틀린 파일에서 클래스 멤버가 아닌 최상위 함수와 프로퍼티를 직접 선언할 수 있다.
- 확장 함수와 프로퍼티를 사용하면 외부 라이브러리에 정의된 클래스를 포함해 모든 클래스의 API를 그 클래스의 소스코드를 바꿀 필요 없이 확장할 수 있다.
- 중위 호출을 통해 인자가 하나 밖에 없는 메소드나 확장 함수를 더 깔끔한 구문으로 호출할 수 있다.
  - 로컬 함수를 써서 코드를 더 깔끔하게 유지하면서 중복을 제거할 수 있다.    

# 4장 클래스, 객체, 인터페이스

코틀린은 자바와 다르게 인터페이스에 프로퍼티 선언이 들어갈 수 있다. 자바와 달리 코틀린 선언은 기본적으로 final이며 public이다. 게다가 중첩 클래스는 기본적으로 내부 클래스가 아니다. 즉 코틀린의 중첩 클래스에는 외부 클래스에 대한 참조가 없다.

## 4.1 클래스 계층 정의

### 4.1.1 코틀린 인터페이스

코틀린 인터페이스 안에는 추상 메소드뿐 아니라 구현이 있는 메소드도 정의할 수 있다. 다만 인터페이스에는 아무런 상태도 들어갈 수 없다.

```kotlin
interface Clickable {
	fun click()
}

//인터페이스 구현
class Button: Clickable {
	override fun click() = println("Clicked")
}
```

클래스 이름 위에 :을 붙이고 인터페이스와 클래스 이름을 적는 것으로 클래스 확장과 인터페이스 구현을 모두 처리한다.

override 변경자는 상위 클래스나 상위 인터페이스에 있는 프로퍼티나 메소드를 오버라이드한다는 표시다. 하지만 자바와는 달리 override 변경자를 꼭 사용해야 한다. override 변경자는 실수로 상위 클래스의 메소드를 override하는 것을 방지해준다.

디폴트 메소드는 default를 붙일 필요가 없다.

```kotlin
interface Clickable {
	fun click()
	fun showOff() = println("Clickable!")
```

동일한 메소드를 구현하는 다른 인터페이스를 함께 구현하는 경우 컴파일 에러가 발생하기 때문에 두 메소드를 아우르는 구현을 하위 클래스에 직접 구현하게 강제한다.

```kotlin
Class Button : Clickable, Focusable {
	override fun click() = println("Clicked")
	override fun showOff() {
		super<Clickable>.showOff() // 상위 타입의 이름을 꺽쇠 괄호 사이에 넣어서 super를 지정
		super<Focusable>.showOff()
	}
```

### 4.1.2 open, final, abstract 변경자: 기본적으로 final

취약한 기반 클래스라는 문제는 하위 클래스가 기반 클래스에 대해 가졌던 가정이 기반 클래스를 변경함으로써 깨져버리는 경우에 생긴다.

특별히 하위 클래스에서 오버라이드하게 의도된 클래스와 메소드가 아니라면 모두 final로 만들라는 뜻이다.

자바의 클래스와 메소드는 기본적으로 상속에 대해 열려있지만 코틀린의 클래스와 메소드는 기본적으로 final이다.

어떤 클래스의 상속을 허용하려면 클래스 앞에 open 변경자를 붙여야 한다. 그와 더불어 오버라이드를 허용하고 싶은 메소드나 프로퍼티 앞에도 open 변경자를 붙여햐 한다.

```kotlin
open class RichButton : Clickable {
	fun disabled() {} // 메소드 오버라이드 안됨
	open fun animate() {} //오버라이드 가능
	override fun clicke() {} // 오버라이드한 메소드는 기본적으로 open
```

오버라이드하는 메소드의 구현을 하위 클래스에서 오버라이드 하지 못하게 금지하려면 오버라이드하는 메소드 앞에 final을 명시해야 한다.

추상 클래스의 추상 멤버 앞에는 open 변경자를 붙일 필요가 없다. 항상 열려 있다.
추상 클래스에 속했더라도 비추상 함수는 기본적으로 파이널이지만 원한다면 open으로 오버라이드를 할 수 있다.

### 4.1.3 가시성 변경자: 기본적으로 공개

가시성 변경자는 코드 기반에 있는 선언에 대한 클래스 외부 접근을 제어한다.

코틀린의 기본 가시성은 public이다. 코틀린은 패키지를 네임스페이스를 관리하기 위한 용도로만 사용한다. 그래서 패키지를 가시성 제어에 사용하지 않는다.

패키지 전용 가시성에 대한 대안으로 코틀린에는 internal이라는 새로운 가시성 변경자를 도입했다. internal은 ‘모듈 내부에서만 볼 수 있음’이라는 뜻이다. 모듈은 한 번에 한꺼번에 컴파일되는 코틀린 파일들을 의미한다.

모듈 내부 가시성은 모듈의 구현에 대해 진정한 캡슐화를 제공한다는 장점이 있다.

다른 차이는 코틀린에서는 최상위 선언에 대해 private 가시성을 허용한다는 점이다.

자바에서는 같은 패키지 안에서 protected 멤버에 접근할 수 있지만, 코틀린에서 protected 멤버는 오직 어떤 클래스나 그 클래스를 상속한 클래스 안에서만 보인다. 클래스를 확장한 함수는 그 클래스의 private이나 protected 멤버에 접근할 수 없다.

### 4.1.4 내부 클래스와 중첩된 클래스: 기본적으로 중첩 클래스

코틀린의 중첩클래스는 명시적으로 요청하지 않는 한 바깥쪽 클래스 인스턴스에 대한 접근 권한이 없다.

코틀린 중첩 클래스에 아무런 변경자가 붙지 않으면 자바 static 중첩 클래스와 같다. 이를 내부 클래스로 변경해서 바깥쪽 클래스에 대한 참조를 포함하게 만들고 싶다면 inner 변경자를 붙여야 한다.

내부 클래스 Inner 안에서 바깥쪽 클래스 Outer의 참조에 접근하려면 this@Outer라고 써야한다.

```kotlin
class Outer {
	inner class Inner{
		fun getOuterReference() : Outer = this@Outer
	}
}
```

### 4.1.5 봉인된 클래스: 클래스 계층 정의 시 계층 확장 제한

상위 클래스에 sealed 변경자를 붙이면 그 상위 클래스를 상속한 하위 클래스 정의를 제한할 수 있다.

```kotlin
//as is
interface Expr
class Num(val value:Int) : Expr
class Sum(val left: Expr, val right: Expr) : Expr

//to be
sealed class Expr {
	class Num(val value: Int) : Expr()
	class Sum(val left: Expr, val right: Expr) : Expr()
```

봉인된 클래스는 외부에 자신을 상속한 클래스를 둘 수 없다.
내부적으로 Expr 클래스는 private 생성자를 가진다.

## 4.2 뻔하지 않은 생성자와 프로퍼티를 갖는 클래스 선언

코틀린은 주생성자와 부생성자를 구분한다. 또한 코틀린에서는 초기화 블록을 통해 초기화 로직을 추가할 수 있다.

### 4.2.1 클래스 초기화: 주 생성자와 초기화 블록

```kotlin
class User(val nickname: String)
```

이렇게 클래스 이름 뒤에 오는 괄호로 둘러싸인 코드를 주 생성자라고 부른다. 주 생성자는 생성자 파라미터를 지정하고 그 생성자 파라미터에 의해 초기화되는 프로퍼티를 정의하는 두 가지 목적에 쓰인다. 이 선언을 같은 목적을 달성할 수 있는 가장 명시적인 선언으로 풀어서 실제로는 어떤 일이 벌어지는지 살펴보자.

```kotlin
class User constructor(_nickname: String) {
	val nickname: String
	
	init { // 초기화 블록
		nickName = _nickname
	}
}
```

constructor 키워드는 주 생성자나 부 생성자 정의를 시작할 때 사용한다. init 키워드는 초기화 블록을 시작한다.

주 생성자의 파라미터로 프로퍼티를 초기화한다면 그 주 생성자 파라미터 이름 앞에 val을 추가하는 방식으로 프로퍼티 정의와 초기화를 간략히 쓸 수 있다.

```kotlin
class User(val nickName: String) // val은 이 파라미터에 상응하는 프로퍼티가 생성된다는 뜻이다.
```

생성자 파라미터에도 디폴트 값을 정의할 수 있다.

```kotlin
class User(val nickname: String, val isSubscribed: Boolean = true)
```

모든 생성자 파라미터에 디폴트 값을 지정하면 컴파일러가 자동으로 파라미터가 없는 생성자를 만들어준다.

클래스에 기반 클래스가 있다면 주 생성자에서 기반 클래스의 생성잘르 호출해야할 필요가 있다. 기반 클래스를 초기화하려면 기반 클래스 이름 뒤에 괄호를 치고 생성자 인자를 넘긴다.

```kotlin
open class User(val nicknames: String) {...}
class TwitterUser(nickname: String) : User(nickname){...}
```

클래스를 정의할 때 별도로 생성자를 정의하지 않으면 컴파일러가 자동으로 아무일도 하지 않는 인자가 없는 디폴트 생성자를 만들어준다.

```kotlin
open class Button
```

Button의 생성자는 아무 인자도 받지 않지만, Button 클래스를 상속한 하위 클래스는 반드시 Button 클래스의 생성자를 호출해야 한다.

```kotlin
class RadioButton: Button()
```

이 규칙으로 인해 기반 클래스의 이름 뒤에는 꼭 빈 괄호가 들어간다.

클래스 정의에 있는 상위 클래스 및 인터페이스 목록에서 이름 뒤에 괄호가 붙어있는지 살펴보면 쉽게 기반 클래스와 인터페이스를 구별할 수 있다.

어떤 클래스를 클래스 외부에서 인스턴스화하지 못하게 막고 싶다면 모든 생성자를 private으로 만들변 된다.

```kotlin
class Secretive private constructor() {}
```

### 4.2.2 부 생성자: 상위 클래스를 다른 방식으로 초기화

this()를 통해 클래스 자신의 다른 생성자를 호출할 수 있다.

```kotlin
Class MyButton : View {
	constructor(ctx: Context) : this(ctx, MY_STYLE) {...}
	constructor(ctx: Context, attr: AttributeSet) : super(ctx, attr) {...
```

클래스에 주 생성자가 없다면 모든 부 생성자는 반드시 상위 클래스를 초기화하거나 다른 생성자에게 생성을 위임해야 한다. 각 부 생성자에서 객체 생성을 위임하는 화살표를 따라가면 그 끝에는 상위 클래스 생성자를 호출하는 화살표가 있어야 한다.

### 4.2.3 인터페이스에 선언된 프로퍼티 구현

코틀린에서는 인터페이스에 추상 프로퍼티 선언을 넣을 수 있다.

```kotlin
interface User {
	val nickname: String
}

class PrivateUser(override val nickname: String) : User // 주 생성자에 있는 프로퍼티

class SubscribingUser(val email: String) : User {
	override val nickname: String
		get() = email.substringBefore('@') // 커스텀 게터
}

class FacebookUser(val accountId: Int) : User {
	override val nickname = getFacebookName(accountId)
}
```

PrivateUser는 주 생성자 안에 프로퍼티를 직접 선언하는 간결한 구문을 사용한다.

이 프로퍼티는 User의 추상 프로퍼티를 구현하고 있으므로 override를 표시해야 한다.

SubscribingUser는 커스텀 게터로 nickname 프로퍼티를 설정한다. 이 프로퍼티는 뒷받침하는 필드에 값을 저장하지 않고 매번 이메일 주소에서 별명을 계산해서 반환한다.

사용자 ID를 받아서 그 사용자의 이름을 반환해주는 getFacebookName 함수를 호출해서 nickname을 초기화 한다.

SubscribingUser의 nickname은 매번 호출될 때마다 substringBefore를 호출해 계산하는 커스텀 게터를 활용하고, FacebookUser의 nickname은 객체 초기화 시 계산한 데이터를 뒷받침하는 필드에 저장했다가 불러오는 방식을 활용한다.

인터페이스에는 추상 프로퍼티뿐 아니라 게터와 세터가 있는 프로퍼티를 선언할 수도 있다. 물론 그런 게터와 세터는 뒷받침하는 필드를 참조할 수 없다.

### 4.2.4 게터와 세터에서 뒷받침하는 필드에 접근

값을 저장하는 프로퍼티와 커스텀 접근자에서 매번 값을 계산하는 프로퍼티에 대해 살펴봤다. 이제 이 두 유형을 조합해서 어떤 값을 저장하되 그 값을 변경하거나 읽을 때마다 정해진 로직을 실행하는 유형의 프로퍼티를 만드는 방법을 살펴보자. 값을 저장하는 동시에 로직을 실행할 수 있게 하기 위해서는 접근자 안에서 프로퍼티를 뒷받침하는 필드에 접근할 수 있어야 한다.

코틀린에서 프로퍼티의 값을 바꿀 때는 user.address = “new value”처럼 필드 설정 구문을 사용한다.

변경 가능한 프로퍼티의 게터와 세터 중 한쪽만 직접 정의해도 된다.

### 4.2.5 접근자의 가시성 변경

접근자의 가시성은 기본적으로는 프로퍼티의 가시성과 같지만 원한다면 get이나 set 앞에 가시성 변경자를 추가해서 접근자의 가시성을 변경할 수 있다.

```kotlin
class LengthCounter {
	var counter: Int = 0
		private set
}
```

## 4.3 컴파일러가 생성한 메소드: 데이터 클래스와 클래스 위임

### 4.3.1 모든 클래스가 정의해야 하는 메소드

**문자열 표현: toString()**

기본 구현을 바꾸려면 toString 메소드를 오버라이드해야 한다.

**객체의 동등성: equals()**

코틀린에서는 == 연산자가 두 객체를 비교하는 기본적인 방법이다. ==는 내부적으로 equals를 호출해서 객체를 비교한다. 참조 비교를 위해서는 === 연산자를 사용할 수 있다.

코틀린의 is 검사는 자바의 instanceOf와 같다.

**해시 컨테이너: hashCode()**

HashSet은 원소를 비교할 때 비용을 줄이기 위해 먼거 객체의 해시 코드를 비교하고 해시 코드가 같은 경우에만 실제 값을 비교한다. 해시 코드가 다를 때 equals가 반환하는 값은 판단 결과에 영향을 끼치지 못한다.

코틀린 컴파일러는 이 모든 메소드를 자동으로 생성해줄 수 있다.

### 4.3.2 데이터 클래스: 모든 클래스가 정의해야 하는 메소드 자동 생성

코틀린에서는 data라는 변경자를 클래스 앞에 붙이면 필요한 메소드를 컴파일러가 자동으로 만들어준다.

data 변경자가 붙은 클래스를 데이터 클래스라고 부른다.

```kotlin
data class Client(val name: String, val postalCode: Int)
```

코틀린 컴파일러는 data 클래스에게 방금 말한 세 메소드뿐 아니라 몇 가지 유용한 메소드를 더 생성해준다.

**데이터 클래스와 불변성: copy() 메소드**

데이터 클래스의 프로퍼티가 꼭 val일 필요는 없지만 데이터 클래스의 모든 프로퍼티를 읽기 전용으로 만드어서 불변 클래스로 만들라고 권장한다.

데이터 클래스 인스턴스를 불변 객체로 더 쉽게 활용할 수 있게 코틀린 컴파일러는 한 가지 편의 메소드를 제공한다. 그 메소드는 객체를 복사하면서 일부 프로퍼티를 바꿀 수 있게 해주는 copy메소드다.

### 4.3.3 클래스 위임: by 키워드 사용

대규모 객체 지향 시스템을 설계할 때 시스템을 취약하게 만드는 문제는 보통 구현 상속에 의해 발생한다. 하위 클래스가 상위 클래스의 메소드 중 일부를 오버라이드하면 하위 클래스는 상위 클래스의 세부 구현사항에 의존하게 된다.

코틀린은 기본적으로 클래스를 final로 취급하기로 결정했다. 모든 클래스를 기본적으로 final로 취급하면 상속을 염두해두고 open 변경자로 열어둔 클래스만 확장할 수 있다. 열린 상위 클래스의 소스코드를 변경할 때는 open 변경자를 보고 해당 클래스를 다른 클래스가 상속하리라 예상할 수 있으므로, 변경 시 하위 클래스를 깨지 않기 위해 좀 더 조심할 수 있다.

하지만 종종 상속을 허용하지 않는 클래스에서 새로운 동작을 추가해야할 때가 있다. 이럴 때 사용하는 일반적인 방법이 **데코레이터 패턴**이다.

인터페이스를 구현할 때 by 키워드를 통해 그 인터페이스에 대한 구현을 다른 객체에 위임 중이라는 사실을 명시할 수 있다.

```kotlin
class DelegatingCollection<T> {
	innerList: Collection<T> = ArrayList<T>()
} : Collections<T> by innerList()
```

## 4.4 object 키워드: 클래스 선언과 인스턴스 생성

코틀린에서는 object 키워드를 다양한 상황에서 사용하지만 모든 경우 클래스를 정의하면서 동시에 인스턴스 객체를 생성한다는 공통점이 있다. object 키워드를 사용하는 여러 상황을 살펴보자.

- 객체 선언은 싱글턴을 정의하는 방법 중 하나다.
- 동반 객체는 인스턴스 메소드는 아니지만 어떤 클래스와 관련 있는 메소드와 팩토리 메소드를 담을 때 쓰인다.
- 객체 식은 자바의 무명 내부 클래스 대신 쓰인다.

### 4.4.1 객체 선언: 싱글턴을 쉽게 만들기

코틀린은 객체 선언 기능을 통해 싱글턴을 언어에서 기본 지원한다. 객체 선언은 클래스 선언과 그 객체에 속한 단일 인스턴스의 선언을 합친 선언이다.

```kotlin
object Payroll {
	val allEmployees = arrayListOf<Person>()
	fun calculateSalary() {
		for (person in allEmployees) {
			...
		}
	}
}
```

객체 선언은 object 키워드로 시작한다. 객체 선언은 클래스를 정의하고 그 클래스의 인스턴스를 만들어서 변수에 저장하는 모든 작업을 단 한문장으로 처리한다.

생성자는 객체 선언에 쓸 수 없다. 변수와 마찬가지로 객체 선언에 사용한 이름 뒤에 마침표를 붙이면 객체에 속한 메소드나 프로퍼티에 접근할 수 있다.

```kotlin
Payroll.allEmployees.add(Person(...))
Payroll.calculateSalary()
```

객체 선언도 클래스나 인터페이스를 상속할 수 있다.

### 4.4.2 동반 객체: 팩토리 메소드와 정적 멤버가 들어갈 장소

코틀린 언어는 자바 static 키워드를 지원하지 않는다. 그 대신 코틀린에서는 패키지 수준의 최상위 함수와 객체 선언을 활용한다. 대부분의 경우 최상위 함수를 활용하는 편을 더 권장한다. 하지만 최상위 함수는 private으로 표시된 클래스 비공개 멤버에 접근할 수 없다. 그래서 클래스의 인스턴스와 관계없이 호출해야 하지만, 클래스 내부 정보에 접근해야 하는 함수가 필요할 때는 클래스에 중첩된 객체 선언의 멤버 함수로 정의해야 한다. 그럼 함수의 대표적인 예로 팩토리 메소드를 들 수 있다.

클래스 안에 정의된 객체 중 하나에 companion이라는 특별한 표시를 붙이면 그 클래스의 동반 객체로 만들 수 있다. 동반 객체의 프로퍼티나 메소드에 접근하려면 그 동반 객체가 정의된 클래스 이름을 사용한다. 이때 객체의 이름을 따로 지정할 필요가 없다.

```kotlin
class A {
	companion object {
		fun bar() {
			println("Companion object called")
		}
	}
}
```

동반 객체가 private 생성자를 호출하지 좋은 위치다. 동반 객체는 자신을 둘러싼 클래스의 모든 private 멤버에 접근할 수 있다. 따라서 동반 객체는 바깥쪽 클래스의 private 생성자도 호출할 수 있다.

```kotlin
class User private constructor(val nickname: String) {
	companion object {
		fun newSubscribingUser(email: String) = User(email.substringBefore('@')
		fun newFacebookUser(accountId: Int) = User(getFacebookName(accountId))
	}
}

>>> val subscribingUser = User.newSubscribingUser("bob@gmail.com")
```

팩토리 메소드는 그 팩토리 메소드가 선언된 클래스의 하위 클래스 객체를 반환할 수도 있다.

### 4.4.3 동반 객체를 일반 객체처럼 사용

동반 객체는 클래스 안에 정의된 일반 객체다. 따라서 동반 객체에 이름을 붙이거나, 동반 객체가 인터페이스를 상속하거나, 동반 객체 안에 확장 함수와 프로퍼티를 정의할 수 있다.

**동반 객체에서 인터페이스 구현**

**동반 객체 확장**

```kotlin
// 비즈니스 로직 모듈
class Pserson(val firstName: String, val lastName: String) {
	companion object {
	}
}

// 클라이언트/서버 통신 모듈
fun Person.companion.fromJson(json: String) : Person {
	...
}

val p = Person.fromJSON(json)
```

### 4.4.4 객체 식: 무명 내부 클래스를 다른 방식으로 작성

무명 객체를 정의할 때도 object 키워드를 쓴다. 무명 객체는 자바의 무명 내부 클래스(익명 내부 클래스)를 대신한다.

```kotlin
window.addMouseListener(
	object: MouseAdapter() {
		override fun mouseClicked(e: MouseEvent) {
		 ...
```

## 4.5 요약

- 코틀린의 인터페이스는 자바 인터페이스와 비슷하지만 디폴트 구현을 포함할 수 있고, 프로퍼티도 포함할 수 있다.
- 모든 코틀린 선언은 기본적으로 final이며 public이다.
- 선언이 final이 되지 않게 만들려면 앞에 open을 붙여야 한다.
- internal 선언은 같은 모듈 안에서만 볼 수 있다.
- 중첩 클래스는 기본적으로 내부클래스가 아니다. 바깥쪽 클래스에 대한 참조를 중첩 클래스 안에 포함시키려면 inner 클래스를 중첩 클래스 선언 앞에 붙여서 내부 클래스로 만들어야 한다.
- sealed 클래스를 상속하는 클래스를 정의하려면 반드시 부모 클래스 정의 안에 중첩 클래스로 정의해야 한다.
- 초기화 블록과 부 생성자를 활용해 클래스 인스턴스를 더 유연하게 초기화할 수 있다.
- field 식별자를 통해 프로퍼티 접근자 안에서 프로퍼티의 데이터를 저장하는 데 쓰이는 뒷받침하는 필드를 참조할 수 있다.
- 데이터 클래스를 사용하면 컴파일러가 equals, hashCode, toString, copy 등의 메소드를 자동생성해준다.
- 클래스 위임을 사용하면 위임 패턴을 구현할 때 필요한 수많은 성가신 준비 코드를 줄일 수 있다.
- 객체 선언을 사용하면 코틀린답게 싱글턴 클래스를 정의할 수 있다.
- 동반 객체는 자바의 정적 메소드와 필드 정의를 대신한다.
- 동반 객체도 다른 객체와 마찬가지로 인터페이스를 구현할 수 있다. 외부에서 동반 객체에 대한 확장 함수와 프로퍼티를 정의할 수 있다.
- 코틀린의 객체 식은 자바의 무명 내부 클래스를 대신한다.

# 5장 람다식 프로그래밍

람다식 또는 람다는 기본적으로 다른 함수에 넘길 수 있는 작은 코드 조각을 뜻한다.

## 5.1 람다 식과 멤버 참조

### 5.1.1 람다 소개: 코드 블록을 함수 인자로 넘기기

“이벤트가 발생하면 이 핸들러를 실행하자”나 “데이터 구조의 모든 원소에 이 연산을 적용하자”와 같은 생각을 코드로 표현하기 위해 일련의 동작을 변수에 저장하거나 다른 함수에 넘겨야하는 경우가 자주 있다. 예전에 자바에서는 무명 내부 클래스를 통해 이런 목적을 달성했다.

이와 달리 함수형 프로그래밍에서는 함수를 값처럼 다루는 접근 방법을 택함으로써 이 문제를 해결한다.

### 5.1.2 람다와 컬렉션

### 5.1.3 람다 식의 문법

```kotlin
{ x: Int, y: Int -> x + y} // 항상 중괄호 사이에 위치함
```

람다 식을 변수에 저장할 수도 있다.

```kotlin
val sum = { x: Int, y: Int -> x + y}
```

코드의 일부분을 블록으로 둘러싸 실행할 필요가 있다면 run을 사용한다.

코틀린에는 함수 호출 시 맨 뒤에 있는 인자가 람다 식이라면 그 람다를 괄호 밖으로 빼낼 수 있다는 문법 관습이 있다. 람다가 어떤 함수의 유일한 인자이고 괄호 뒤에 람다를 썼다면 호출 시 빈 괄호를 없애도 된다.

람다의 파라미터가 하나뿐이고 그 타입을 컴파일러가 추론할 수 있는 경우 it를 바로 쓸 수 있다.

```kotlin
people.maxBy{it.age}
```

### 5.1.4 현재 영역에 있는 변수에 접근

자바 메소드 안에서 무명 내부 클래스를 정의할 때 메소드의 로컬 변수를 무명 내부 클래스에서 사용할 수 있다. 람다를 함수 안에서 정의하면 함수의 파라미터뿐 아니라 람다 정의의 앞에 선언된 로컬 변수까지 람다에서 모두 사용할 수 있다.

자바와 다른 점 중 중요한 한 가지는 코틀린 람다 안에서는 파이널 변수가 아닌 변수에 접근할 수 있다는 점이다. 또한 람다 안에서 바깥의 변수를 변경해도 된다.

파이널 변수를 포획한 경우에는 람다 코드를 변수 값과 함께 저장한다. 파이널이 아닌 변수를 포획한 경우에는 변수를 특별한 래퍼로 감싸서 나중에 변경하거나 읽을 수 있게 한다음, 래퍼에 대한 참조를 람다 코드와 함께 저장한다.

### 5.1.5 멤버 참조

```kotlin
val getAge = Person::age

val getAge = {person: Person -> person.age}
```

::를 사용하는 식을 멤버 참조라고 부른다. 멤버 참조는 프로퍼티나 메소드를 단 하마나 호출하는 함수 값을 만들어준다.

최상위에 선언된 함수나 프로퍼티를 참조할 수도 있다.

```kotlin
fun salute() = println("Salute!")
>>> run(::salue)
```

## 5.2 컬렉션 함수형 API

함수형 프로그래밍 스타일을 사용하면 컬렉션을 다룰 때 편리하다.

### 5.2.1 필수적인 함수: filter와 map

filter 함수는 컬렉션을 이터레이션하면서 주어진 람다에 각 원소를 넘겨서 람다가 true를 반환하는 원소만 모은다.

```kotlin
val list = listOf(1, 2, 3, 4)

>>> println(list.filter { it % 2 == 0 }
[2, 4]
```

map 함수는 주어진 람다를 컬렉션의 각 원소에 적용한 결과를 모아서 새 컬렉션을 만든다.

```kotlin
>>> val list = listOf(1, 2, 3, 4)
>>> println(list.map { it * it })
[1, 4, 9, 16]
```

### 5.2.2 all, any, count, find: 컬렉션에 술어 적용

컬렉션에 대해 자주 수행하는 연산으로 컬렉션의 모든 원소가 어떤 조건을 만족하는지 판단하는 연산이 있다. 코틀린에서는 all과 any가 이런 연산이다. count 함수는 조건을 만족하는 원소의 개수를 반환하며, find 함수는 조건을 만족하는 첫 번째 원소를 반환한다.

```kotlin
val canBeInClub27 = { p: Person -> p.age <= 27 }

>>> val people = listOf(Person("a", 27), Person("b", 31))
>>> println(people.any(canBeInClub27))
```

### 5.2.3 groupBy: 리스트를 여러 그룹으로 이뤄진 맵으로 변경

```kotlin
>>> val poeple = listOf(Person("a", 31), Person("b", 29)...)
>>> println(people.groupBy { it.age })
```

groupBy의 결과 타입은 Map<Int, List<Person>>이다.

### 5.2.4 flatMap과 flatten: 중첩된 컬렉션 안의 원소 처리

```kotlin
class Book(val title: String, val authors: List<String>)

books.flatMap { it.authors }.toSet()
```

flatMap 함수는 먼저 인자로 주어진 람다를 컬렉션의 모든 객체에 적용하고 람다를 적용한 결과 얻어지는 여러 리스트를 한 리스로 한데 모은다.

리스트의 리스트를 한 리스트로 모아야 한다면 listOfLists.flatten() 처럼 flatten 함수를 사용할 수 있다.

# 6장 코틀린 타입 시스템

# 7장 연산자 오버로딩과 기타 관례

# 8장 고차 함수: 파라미터와 반환 값으로 람다 사용

# 9장 제네릭스

# 10장 애노테이션과 리플렉션

# 11장 DSL 만들기